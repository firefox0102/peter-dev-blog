---
title: Don't Weld Your Frontend Technologies Together
tags: ["Redux", "Separation of Concerns"]
date: 2020-05-25
featuredImage: welding.jpeg
embeddedImages:
  - allAppLayers.png
  - angularOnFire.png
  - filesForLayers.png
  - stickShift.jpeg
---

##### Quick Primer

We have probably all been told at one point or another that Separation of Concerns is a wise thing to maintain, but I find that frontend software development very commonly commits the sin of welding technologies together so they can never be separated again. This post is more about the architectural patterns that I use to avoid this pitfall, and although I focus on Redux you can implement these same patterns in lots of different ways, with lots of different technologies.
First Impressions Can Be Misleading

### Separation of Concerns

This may come as a surprise to some people, but I used to be pretty opposed to redux. Although I had never really used it in depth, I was turned off by the classic arguments against it like a lot of overhead to get started, slower development, the boilerplate code it required, and an instinct I have to try to stay as close to vanilla React as possible. Sure, Redux gives you pretty manual control over your application control flow and can help you to simplify things a lot, but it felt like driving a Stick Shift vs Automatic.

I don’t know about you, but I don’t want to control every little thing about shifting gears when I can just drive an automatic.

<EmbeddedImage
  src={props.embedded.image4}
  width={["75%"]}
  justifyContent="center"
/>

However, after working with Redux in a large application for a while I have to say it’s growing on me. In an enterprise application that spans multiple product surfaces, it’s often hard to figure out what the control flow of a certain feature or page in the app is. However, with Redux you have a predictable pattern for control flow and it only takes a little bit of digging to follow how exactly that To Do list feature you built two years ago is working. Along with the help of Redux-toolkit, which greatly reduces the boilerplate you have to write, I have really started to enjoy working with Redux, but that’s not to say it doesn’t have flaws.

_Boilerplate code_ is one of the complaints against Redux that I think is perfectly valid! If you’re a small startup with a relatively manageable codebase, I completely agree that this is probably too much work! You need to prioritize speed of delivery over everything else so your business can survive. However, I would still argue that it is smart to have some sort of separation of concerns in your app, and there’s a very specific instance that I learned this lesson.

#### The Death of AngularJS

<EmbeddedImage
  src={props.embedded.image2}
  width={["75%"]}
  justifyContent="center"
/>

Imagine you’re a medium sized business who’s just made it through a few years of painstaking growth, and you’ve finally managed to make it to a pretty comfortable place in your business. You’re no longer in danger of going bankrupt every week, and you can start to focus on quality a little more. This is exactly where SalesLoft found itself in January of 2018 when it was announced that AngularJS was being deprecated by Google. Overnight, our app went from decent quality with a few minor issues to approaching extinction.

The demise of AngularJS was such a shock for so many developers because it did EVERYTHING for you. It handled app state, control flow, data fetching, presentation. Our entire application was written in AngularJS and suddenly Google had just volunteered us for an entire app rewrite.

This is why I find separation of concerns so vital in frontend architecture. It’s so easy to just constantly focus on execution and speed of development, but you need to think long term about some of the things that could kill your business, or at the least cause all of your dev team to quit because they’re forced to work with “ancient” (see: 4 years old) technologies.

#### Clean Separation of Concerns

So how do we achieve a clear separation of concerns without causing too much extra overhead for speed of development? Great question!

Here’s a simple example that illustrates our current redux control flow. For the sake of brevity I will do a bit of hand waving over some details, but feel free to read Part 2 for this post to see more detail about the specific layers.

<EmbeddedImage
  src={props.embedded.image3}
  width={["100%"]}
  justifyContent="center"
/>

Some developers might think that this is a lot of code to simply hit the API and return some data! Isn’t it easier to fetch data directly in your React components?

It might seem like a waste of time now, but if your company ever decided to completely switch View libraries (trust me it’s not that uncommon) you’ll have saved yourself years of a painstaking application rewrite.

# Application Layers

Now let’s discuss the specifics of each of these layers at a high level, and how we’re achieving a very clear separation of concerns here. Each of these is meant to help you dodge a specific bullet that I’ve encountered!

<EmbeddedImage
  src={props.embedded.image1}
  width={["100%"]}
  justifyContent="center"
/>

### Data Access Layer

Early in my career I would’ve considered fetching data and storing it in app state as “Business Logic.” However, I think it’s wise to separate these two concepts out for the same reason you might want to decouple your app state from your view library. Say you’ve been using Axios for a while and suddenly a cool new fetch library comes out that your team wants to start using instead.
By having a clear interface between your App Control Flow code, you can easily swap out this library with very little change. In contrast, if every single Redux Action has code that is directly invoking Axios, you’ve welded together your data fetching technology with your control flow and now have to do a lot more work to swap out technologies.

### Control Flow Layer

This is where you dispatch events and fetch data. I won’t go into too much detail here as it’s mostly just stock Redux, but there is one thing I want to highlight about this layer.

** Selectors! **

Selectors are a newer concept to the Redux ecosystem, and they are essentially an interface between your presentation layer and your app state. You might also use Containers for this, although the ability to mix, match, and combine selectors makes them far superior IMHO.
The use of Selectors is incredibly important for this one reason: It abstracts the shape of your application state out of your presentational layer. Selectors allow you to keep your App State separated from some of the details your presentation layer might need. For example, if a component needs a number formatted as a percentage, your selector can handle the transformation of the data on the fly instead of storing the data in app state.

### Presentational Layer

This layer is important because it opens your app up to swap out your view library without having to re-write your entire application from the ground up. It also allows you to have multiple technologies running in tandem if you want to. Congrats now you can have micro-frontends, go nuts!

** Note: ** Some developers use the term “Presentational” to refer to functional components that hold no local state. In this instance, I’m actually treating all React/Vue/Angular code as Presentational because it’s really only concerned with how to display things to the user. I prefer to keep specific pieces of local state as close to the components that need them as possible, such as the state of a dropdown menu. IMHO that’s “view” logic, not app logic.

#### That's It For Now!

This post is pretty high level, but hopefully you've come away with some inspiration for how you can think about your own frontend code and how to protect yourself from a full re-write.

** I will never forgive Google for AngularJS **
